# 热门100题

!!! info "说明"
    本文为笔者练习leetcode热门100题时的思考和感悟，可能会存在一些疏漏

## 两数和
!!! question "两数之和"
    给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出和为目标值`target `的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

看到这道题的第一反应是暴力解法，遍历数组中的所有两数对直至找到正确解，这用两个`for`循环可以轻松实现。
``` c++ linenums="1"
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        for (int i=0; i<nums.size()-1; i++) {
            for (int j=i+1; j<nums.size(); j++) {
                if (nums[i] + nums[j] == target) {
                    result.push_back(i);
                    result.push_back(j);
                    return result;
                }
            }
        }
        return result;
    }
};
```

但显然遍历的时间复杂度为$O(N^2)$，在数组较大时的性能堪忧。想要更快地找到解，我们有两个思路：

!!! note ""
    1. 对数组进行操作（显然有序数组可以很方便地在$O(N)$的复杂度内找到解）
    2. 更快地查找数组（哈希表！）

再深入思考一下，使用`qsort`也会带入$O(Nlog(N))$的复杂度，而且排序会影响原本的数组下标，因此使用哈希表是一个更为实惠的选择，毕竟在没有冲突的情况下查找的时间复杂度仅为$O(1)$。

!!! success "哈希解法"
    我们可以将`num1 + num2 = target`变形为`num1 = target - num2`，从而转化为一个查找问题。因此我们以`(nums[i],i)`组成数和对应下标的键值对，再通过遍历的方式进行查找。
    ``` c++ linenums="1" hl_lines="10"
    class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            std::unordered_map<int, int> hash;
            for (int j=0; j<nums.size(); j++) {
                int remainder = target - nums[j];
                if (hash.find(remainder) != hash.end() && hash[remainder] != j) {
                    return {j, hash[remainder]};
                } else {
                    hash[nums[j]] = j;
                }
            }
            return {};
        }
    };
    ```

    !!! tip "比较有趣的是，我们可以选择在查找哈希表的过程中插入键值对，虽然看起来很怪，但这确实在一般情况下比一开始就创建一个完整的哈希表来的快。"

---

## 字母异位词分组
!!! question "字母异位词分组"
    给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。字母异位词是由重新排列源单词的所有字母得到的一个新单词。示例如下：
    > 输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]<br>输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

显然这也是一个哈希应用题，问题在于如何将不同排列的字符串归于同一个哈希值。

!!! success ""
    === "排序"
        对于异位字符串，将其进行字典序排序得到的字符串显然是相同的
        > eat/ate -> aet

        因此我们以排序后的字符串作为键值即可将异位词归入一个哈希项
        
        ``` c++ linenums="1"
        class Solution {
        public:
            vector<vector<string>> groupAnagrams(vector<string>& strs) {
                vector<vector<string>> result;
                unordered_map<string, vector<string>> map;
                for (string& it : strs) {
                    string str = it;
                    sort(str.begin(), str.end());
                    map[str].emplace_back(it);
                }
                for (auto it : map) {
                    result.emplace_back(it.second);
                }
                return result;
            }
        };
        ```

    === "计数"
        异位词的每个字符的出现次数是一样的，按照字典序对每个出现的字符排序，并在字符后加上字符数，得到一个异位词的特有的键值

        ``` java linenums="1"
        class Solution {
            public List<List<String>> groupAnagrams(String[] strs) {
                return new ArrayList<>(Arrays.stream(strs)
                    .collect(Collectors.groupingBy(str -> {
                        int[] counter = new int[26];
                        for (int i = 0; i < str.length(); i++) {
                            counter[str.charAt(i) - 'a']++;
                        }
                        StringBuilder sb = new StringBuilder();
                        for (int i = 0; i < 26; i++) {
                            // 这里的 if 是可省略的，但是加上 if 以后，生成的 sb 更短，后续 groupingBy 会更快。
                            if (counter[i] != 0) {
                                sb.append((char) ('a' + i));
                                sb.append(counter[i]);
                            }
                        }
                        return sb.toString();
                    })).values());
            }
        }
        ```

        ??? info "stream 和 collector"
            [`stream`](https://blog.csdn.net/weixin_73869209/article/details/130850722)和[`Collector`](https://blog.csdn.net/xjsj62728/article/details/144144030)这两篇博客可以参考
